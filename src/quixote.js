// Copyright (c) 2014-2017 Titanium I.T. LLC. All rights reserved. For license, see "README" or "LICENSE" file.
"use strict";

var ensure = require("./util/ensure.js");
var QElement = require('./q_element.js');
var QFrame = require("./q_frame.js");
var Size = require("./values/size.js");

var features = null;

exports.createFrame = function(options, callback) {
	return QFrame.create(document.body, options, function(err, callbackFrame) {
		if (features === null) {
			detectBrowserFeatures(function() {
				callback(err, callbackFrame);
			});
		}
		else {
			callback(err, callbackFrame);
		}
	});
};

exports.elementFromDom = function(domElement, nickname) {
	return new QElement(domElement, nickname);
};

exports.browser = {};

exports.browser.enlargesFrameToPageSize = createDetectionMethod("enlargesFrame");
exports.browser.enlargesFonts = createDetectionMethod("enlargesFonts");
exports.browser.misreportsClipAutoProperty = createDetectionMethod("misreportsClipAuto");
exports.browser.misreportsAutoValuesInClipProperty = createDetectionMethod("misreportsClipValues");
exports.browser.roundsOffPixelCalculations = createDetectionMethod("roundsOffPixelCalculations");

function createDetectionMethod(propertyName) {
	return function() {
		ensure.signature(arguments, []);
		ensure.that(features !== null, "Must create a frame before using Quixote browser feature detection.");

		return features[propertyName];
	};
}

function detectBrowserFeatures(callback) {
	var FRAME_WIDTH = 1500;
	var FRAME_HEIGHT = 200;

	features = {};
	var frame = QFrame.create(document.body, { width: FRAME_WIDTH, height: FRAME_HEIGHT }, function(err) {
		if (err) {
			console.log("Error while creating Quixote browser feature detection frame: " + err);
			return callback();
		}

		try {
			features.enlargesFrame = detectFrameEnlargement(frame, FRAME_WIDTH);
			features.misreportsClipAuto = detectReportedClipAuto(frame);
			features.misreportsClipValues = detectReportedClipPropertyValues(frame);
			features.roundsOffPixelCalculations = detectRoundsOffPixelCalculations(frame);

			frame.reset();
			detectFontEnlargement(frame, FRAME_WIDTH, function(result) {
				features.enlargesFonts = result;
				frame.remove();
				return callback();
			});

		}
		catch(err2) {
			console.log("Error during Quixote browser feature detection: " + err2);
		}
	});

}

function detectFrameEnlargement(frame, frameWidth) {
	frame.add("<div style='width: " + (frameWidth + 200) + "px'>force scrolling</div>");
	return !frame.viewport().width.value().equals(Size.create(frameWidth));
}

function detectFontEnlargement(frame, frameWidth, callback) {
	ensure.that(frameWidth >= 1500, "Detector frame width must be larger than screen to detect font enlargement");

	// WORKAROUND IE 8: we use a <div> because the <style> tag can't be added by frame.add(). At the time of this
	// writing, I'm not sure if the issue is with frame.add() or if IE just can't programmatically add <style> tags.
	frame.add("<div><style>p { font-size: 15px; }</style></div>");

	var text = frame.add("<p>arbitrary text</p>");
	frame.add("<p>must have two p tags to work</p>");

	// WORKAROUND IE 8: need to force reflow or getting font-size may fail below
	// This seems to occur when IE is running in a slow VirtualBox VM. There is no test for this line.
	var forceReflow = text.offsetHeight;

	// WORKAROUND Safari 8.0.0: timeout required because font is enlarged asynchronously
	setTimeout(function() {
		var fontSize = text.getRawStyle("font-size");
		ensure.that(fontSize !== "", "Expected font-size to be a value");

		// WORKAROUND IE 8: ignores <style> tag we added above
		if (fontSize === "12pt") return callback(false);

		return callback(fontSize !== "15px");
	}, 0);
}

function detectReportedClipAuto(frame) {
	var element = frame.add("<div style='clip: auto;'></div>");
	var clip = element.getRawStyle("clip");

	return clip !== "auto";
}

function detectReportedClipPropertyValues(frame) {
	var element = frame.add("<div style='clip: rect(auto, auto, auto, auto);'></div>");
	var clip = element.getRawStyle("clip");

	// WORKAROUND IE 8: Provides 'clipTop' etc. instead of 'clip' property
	if (clip === "" && element.getRawStyle("clip-top") === "auto") return false;

	return clip !== "rect(auto, auto, auto, auto)" && clip !== "rect(auto auto auto auto)";
}

function detectRoundsOffPixelCalculations(frame) {
	var element = frame.add("<div style='font-size: 15px;'></div>");
	var size = element.calculatePixelValue("0.5em");

	if (size === 7.5) return false;
	if (size === 8) return true;
	ensure.unreachable("Failure in roundsOffPixelValues() detection: expected 7.5 or 8, but got " + size);
}
